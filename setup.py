# -*- coding: utf-8 -*-
try:
    from setuptools import setup
    from setuptools import find_packages
except ImportError:
    from distutils.core import setup
from distutils.command.build_py import build_py
from distutils.cmd import Command
import os
from pip.req import parse_requirements


def calculate_version():
    # Fetch version from git tags, and write to version.py.
    # Also, when git is not available (PyPi package), use stored version.py.
    import subprocess
    version_py = os.path.join(os.path.dirname(__file__), 'version.py')
    try:
        version_git = subprocess.check_output(["git", "describe"]).rstrip()
    except:
        with open(version_py, 'r') as fh:
            version_git = (open(version_py).read()
                           .strip().split('=')[-1].replace('"', ''))
    version_msg = ('# Do not edit this file, pipeline versioning is '
                   'governed by git tags')
    with open(version_py, 'w') as fh:
        fh.write(version_msg + os.linesep + "__version__=" + version_git)
    return version_git

requirements = [str(ir.req) for ir in parse_requirements('requirements.txt')]
version_git = calculate_version()
os.system('pip install pyandoc==0.0.1')
import platform as p
source_path = '/usr/sources'
os_name = p.system()
systems = {
    'Linux': {
        'update_shared_libs': 'sudo ldconfig',
        'libs': {
            'hdf5': '/usr/local/lib/libhdf5.so.8.0.1',
            'netcdf': '/usr/local/lib/libnetcdf.so.7.2.0'
        }
    },
    'Darwin': {
        'update_shared_libs': '',
        'libs': {
            'hdf5': '/usr/local/lib/libhdf5_hl.8.dylib',
            'netcdf': '/usr/local/lib/libnetcdf.7.dylib'
        }
    }
}


def get_long_description():
    readme_file = 'README.md'
    if not os.path.isfile(readme_file):
        return ''
    # Try to transform the README from Markdown to reStructuredText.
    try:
        import pandoc
        pandoc.core.PANDOC_PATH = 'pandoc'
        doc = pandoc.Document()
        doc.markdown = open(readme_file).read()
        description = doc.rst
    except Exception:
        description = open(readme_file).read()
    return description

from urllib import FancyURLopener


class FakeAgent(FancyURLopener, object):
    version = ('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) '
               'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.149 '
               'Safari/537.36')


class LibraryBuilder(Command):

    def initialize_options(self):
        self.title = '%s %s' % (os_name, p.architecture()[0])
        self.bar = '-' * len(self.title)

    def finalize_options(self):
        pass

    def get(self, path, url, local_path):
        filename = '%s.tar.gz' % path
        local_filename = '%s/%s' % (local_path, filename)
        local_unpacked = '%s/%s' % (local_path, path)
        if not os.path.isfile(local_filename):
            os.system('pip install progressbar==2.2')
            import progressbar as pb
            import tarfile as tar
            widgets = [filename, '  ', pb.Percentage(), ' ',
                       pb.Bar('#', u'\033[34m[', u']\033[0m'),
                       ' ', pb.ETA(), ' ', pb.FileTransferSpeed()]
            bar = pb.ProgressBar(maxval=20, widgets=widgets)

            def dlProgress(count, blockSize, totalSize):
                bar.maxval = totalSize
                status = (count * blockSize if totalSize >= count * blockSize
                          else totalSize)
                bar.update(status)
            downloader = FakeAgent()
            downloader.retrieve('%s/%s' % (url, filename), local_filename,
                                reporthook=dlProgress)
        if not os.path.isdir(local_unpacked):
            tfile = tar.open(local_filename, mode='r:gz')
            tfile.extractall(local_path)
            tfile.close()

    def build_pkg(self, path, pre_config='', post_config=''):
        import multiprocessing
        lib_key = path.split('-')[0].split('/')[-1]
        filename = systems[os_name]['libs'][lib_key]
        if os.path.isfile(filename):
            os.system('sudo rm %s' % filename)
        ncores = multiprocessing.cpu_count()
        os.system(('cd %s; %s ./configure %s; make -j %s; '
                   ' sudo make install')  # check
                  % (path, pre_config, post_config, ncores))
        update_shared_libs = systems[os_name]['update_shared_libs']
        if update_shared_libs:
            os.system(update_shared_libs)

    def install_hdf5(self):
        # Deploy the hdf5 C library
        name = 'hdf5-%s' % '1.8.12'
        self.get(name,
                 'http://www.hdfgroup.org/ftp/HDF5/releases/%s/src' % (name),
                 source_path)
        config_params = '--prefix=/usr/local --enable-shared --enable-hl'
        self.build_pkg('%s/%s' % (source_path, name),
                       post_config=config_params)

    def install_netcdf4(self):
        # Deploy the netcdf4 C library
        name = 'netcdf-%s' % '4.3.1-rc4'
        self.get(name, 'ftp://ftp.unidata.ucar.edu/pub/netcdf', source_path)
        config_params = ('--enable-netcdf-4 --enable-dap --enable-shared'
                         ' --prefix=/usr/local')
        self.build_pkg('%s/%s' % (source_path, name),
                       pre_config=('LDFLAGS=-L/usr/local/lib '
                                   'CPPFLAGS=-I/usr/local/include '
                                   'LD_LIBRARY_PATH=/usr/local'),
                       post_config=config_params)

    def run(self):
        print '+%s+' % self.bar
        print '|%s|' % self.title
        print '+%s+' % self.bar
        import sys
        sys.stdout.flush()
        os.system('pip install numpy==1.8.0 >> tracking.log')
        os.system('sudo mkdir -p %s' % source_path)
        os.system('sudo chmod -R ugo+rwx %s' % source_path)
        self.install_hdf5()
        self.install_netcdf4()


class BuildWrapper(build_py):
    def initialize_options(self):
        print "+--------------------------------+"
        print "|Analizing binary requirements...|"
        print "+--------------------------------+"
        print "for version %s" % version_git
        self.run_command('build_bin_lib')
        build_py.initialize_options(self)


setup(
    name='netcdf',
    version=version_git,
    author=u'Eloy Adonis Colell',
    author_email='eloy.colell@gmail.com',
    packages=find_packages(),
    url='https://github.com/ecolell/netcdf',
    license='MIT License, see LICENCE.txt',
    description='A python library that allow to use one or multiple NetCDF '
                'files in a transparent way through polimorphic methods.',
    long_description=get_long_description(),
    zip_safe=False,
    include_package_data=True,
    install_requires=requirements,
    classifiers=[
        "Intended Audience :: Science/Research",
        "Topic :: Scientific/Engineering :: Atmospheric Science",
        "Topic :: Scientific/Engineering :: Bio-Informatics",
        "Topic :: Scientific/Engineering :: GIS",
        "Topic :: Scientific/Engineering :: Information Analysis",
        "Topic :: Scientific/Engineering :: Physics",
    ],
    cmdclass={
        'build_bin_lib': LibraryBuilder,
        'build_py': BuildWrapper,
    },
)
